# 设计像TinyURL这样的URL缩短服务

## 设计像TinyURL这样的URL缩短服务

让我们设计一个类似TinyURL的URL缩短服务。此服务将提供重定向到长URL的短别名。

类似服务：bit.ly、goo.gl、glink.me等。

难度级别：简单

### 1、为什么我们需要URL缩短？

URL缩短用于为长URL创建较短的别名。我们将这些缩短的别名称为”短链接“。当用户点击这些短链接时，他们会被重定向到原始URL。短链接在显示、打印、发送消息或推文时可以节省大量空间。此外，用户不太可能输入较短的URL。

例如，如果我们通过TinyURL缩短这个页面：

```
https://www.education.io/collection/page/5668639101419520/5649050225344512/5668600916475904/
```

我们会得到：

```
http://tinyurl.com/jlg8zpc
```

缩短的URL几乎是实际URL大小的三分之一。

URL缩短用户优化跨设备的链接、跟踪单个链接以分析受众和用户的活动表现，以及隐藏附属的原始URL。

如果您之前没有使用tinyurl.com，请尝试创建一个新的缩短URL，并花一些时间了解他们的服务提供的各种选项。这对你理解本章有很大帮助。

### 2、系统的要求和目标

> 💡你应该总是在面试开始时明确要求。请务必提出问题，以找到面试官所考虑的系统的确切范围。

我们的网址缩短系统应满足以下要求：

#### 功能要求：

1、给定一个URL，我们的服务应该生成一个更短且唯一的别名。这称为短链接。此链接应该足够短，以便轻松复制并粘贴到应用程序中。

2、当用户访问短链接时，我们的服务应该将他们重定向到原始链接。

3、用户应该能够选择为其URL选择自定义短链接。

4、链接将在标准默认时间跨度后过期。用户应该能够指定到期时间。

#### 非功能要求：

1、系统应该是高可用的。这是必需的，因为如果我们的服务关闭，所有URL重定向将失败。

2、URL重定向应该保证低延迟。

3、缩短的链接是不可预测的。

#### 扩展要求：

1、分析；例如，重定向发生了多少次？

2、其他服务也应该可以通过REST API访问我们的服务。

### 3、容量估计和约束

我们的系统将是重读的。与新的URL缩短相比，会有很多重定向请求。让我们假设读取和写入之间的比率为100:1。

流量估算：假设我们每月将有500M新的URL缩短，以100:1的读/写比率，我们可以预期在同一时期有50B的重定向：

```
100 * 500M => 50B
```

我们系统的每秒查询数（QPS）是多少？每秒新URL缩短：

```
5亿 / (30天 * 24小时 * 3600秒) ~= 200 URLs/s
```

考虑到100:1的读/写比率，每秒的URL重定向将是：

```
100 * 200URL/s =20K/s
```

存储估计；我们假设每个URL缩短请求（和相关的缩短链接）存储5年。由于我们预计每个月有50M个新URL，我们预计存储的对象总数是300亿：

```
5亿 * 5年 * 12个月 = 300亿
```

让那个我们假设每个存储的对象大约有500个字节（只是一个大概的估计——我们稍后会深入研究）。我们讲需要15TB的总存储空间：

```
300亿 * 500bytes = 15TB
```

| **每月 URL 缩短** |    50亿   |
| :-----------: | :------: |
|      总年数      |    5年    |
|    URL对象大小    | 500bytes |
|      文件总数     |   300亿   |
|      总存储量     |   15TB   |

带宽估计：对于写入请求，由于我们预计每秒有200个新URL，因此我们服务的总传入数据将是每秒100KB：

```
200 * 500bytes = 100KB/s
```

对于读取请求，由于我们预计每秒有大约20K URL重定向，因此我们服务的总传出数据将是每秒10MB：

```
20K * 500字节 ～= 10MB/s
```

内存估算：如果我们想缓存一些经常访问的热门URL，我们需要多少内存里存储它们？如果我们遵循80-20规则，即20%的URL产生80%的流量，我们希望缓存这20%的热门URL。

由于我们每秒有2万个请求，我们每天将收到17个请求：

```
20K * 3600秒 * 24小时 ~= 17亿
```

要缓存这20%的这些请求，我们需要170GB的内存。

```
0.2 * 17亿 * 500bytes ~= 170GB
```

这里需要注意的一点是，由于会有很多请求的请求（相同的URL），因此，我们的实际内存使用量将小于170Gb。

高级估计：假设每月个5亿个新的URL和100:1的读写比率，以下是我们系统的高级估计摘要：

|  新网址  |  200/秒  |
| :---: | :-----: |
| 网址重定向 |  20K/s  |
|  传入数据 | 100KB/秒 |
|  传出数据 |  10MB/秒 |
|  储存5年 |   15TB  |
|  缓存内存 |  170GB  |

### 4、系统API

> 💡一旦我们最终确定了需求，定义系统API总是一个好主意。这应该明确对说明对系统的期望。

我们可以使用SOAP或REST API来公开我们的服务的功能。以下可能是用户创建和删除URL的API定义：

```
createURL(apiDevKey, originalURL, customAlias=None, userName=None, expireDate=None)
```

**参数：** apiDevKey (string)：注册账号的API开发者密钥。除其他外，这将用于根据分配的配额限制用户。 originalURL (string)：要缩短的原始 URL。 customAlias (string)：URL 的可选自定义键。 userName (string)：在编码中使用的可选用户名。 expireDate (string)：缩短 URL 的可选过期日期。

**返回：(string)**

成功插入返回缩短的URL；否则，它会返回错误代码。

```
deleteURL(apiDevKey, urlKey)
```

其中“url\_key”是表示要检索的缩短 URL 的字符串。成功删除会返回“URL Removed”。

\*我们如何发现和防止滥用？\*恶意用户可以通过使用当前设计中的所有URL键使我们破产。为了防止滥用，我们可以通过他们的apiDevKey限制用户。每个apiDevKey可以限制为每个时间段内特定数量的URL创建和重定向。（每个开发者密钥可以设置为不同的持续时间）。

### 5、数据库设计

> 💡 在面试的早起阶段定义数据库模式将有助于理解各个组件之间的数据流，然后将指导数据分区。

关于我们将存储的数据性质的一些观察：

1、我们需要存储数十亿条记录。

2、我们存储的每个对象都很小（小于1K）。

3、记录之间没有关系——除了存储哪个用户创建了一个URL。

4、我们的服务读取量很大。

#### **数据库架构：**

我们需要两张表：一张用户存储有关URL映射的信息，另一张用于创建端链接的用户数据。

\\

<figure><img src="../.gitbook/assets/image (10).png" alt=""><figcaption><p>数据库设计</p></figcaption></figure>

我们应该使用什么样的数据库？由于我们预计存储数10亿行，并且我们不需要使用对象之间的关系——像[DynamoDB](https://en.wikipedia.org/wiki/Amazon\_DynamoDB)、[Cassandra](https://en.wikipedia.org/wiki/Apache\_Cassandra)或[Riak](https://en.wikipedia.org/wiki/Riak)这样的NoSql存储是更好的选择。NoSQL选择也更容易扩展。有关详细信息，请参阅[SQL 与 NoSQL ](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5728116278296576/)。

### 6、基本系统设计与算法

我们在这里解决的问题是，如何为给定的URL生成一个简短且唯一的密钥。

在第1节的TinyURL示例中，缩短的 URL 是“ [http://tinyurl.com/jlg8zpc”。这个](http://tinyurl.com/jlg8zpc%E2%80%9D%E3%80%82%E8%BF%99%E4%B8%AA) URL 的最后七个字符是我们要生成的短键。我们将在这里探索两种解决方案：

#### a、编码实际URL

我们可以计算给定URL的唯一哈希值（例如，MD5或SHA256等）。然后可以对散列进行编码以进行显示。这种编码可以是base36 (\[az ,0-9]) 或 base62 (\[AZ, az, 0-9])，如果我们添加'+'和'/'我们可以使用[Base64](https://en.wikipedia.org/wiki/Base64#Base64\_table)编码。一个合理的问题是，短密钥的长度应该是多少？6、8 还是 10 个字符？

对于base64编码，一个6个字母长的键降产生64 ^ 6 \~= 678亿个可能的字符串

使用base64编码，一个 8 个字母长的键将产生 64 ^ 8 \~= 281 万亿个可能的字符串

对于68.7B个唯一字符串，我们假设六个字母键足以满足我们的系统。

如果我们使用 MD5 算法作为我们的散列函数，它将产生一个 128 位的散列值。经过 base64 编码后，我们将得到一个超过 21 个字符的字符串（因为每个 base64 字符编码 6 位哈希值）。现在我们每个键只有 8 个字符的空间，那么我们将如何选择我们的密钥呢？我们可以将前 6 个（或 8 个）字母作为键。这可能会导致密钥重复，为了解决这个问题，我们可以从编码字符串中选择一些其他字符或交换一些字符。

**我们的解决方案有哪些不同的问题？**我们的编码方案存在以下几个问题：

1. 如果多个用户输入相同的 URL，他们可以获得相同的缩短 URL，这是不可接受的。
2. 如果 URL 的某些部分是 URL 编码的怎么办？例如，[http://www.educative.io/distributed.php?id=design和http://www.educative.io/distributed.php%3Fid%3Ddesign除了](http://www.educative.io/distributed.php?id=design%E5%92%8Chttp://www.educative.io/distributed.php%3Fid%3Ddesign%E9%99%A4%E4%BA%86) URL 编码之外是相同的。

**问题的解决方法：** 我们可以将递增的序列号附加到每个输入 URL 以使其唯一，然后生成它的哈希。不过，我们不需要将此序列号存储在数据库中。这种方法可能出现的问题可能是序列号不断增加。能溢出吗？附加增加的序列号也会影响服务的性能。

另一种解决方案可能是将用户 ID（应该是唯一的）附加到输入 URL。但是，如果用户尚未登录，我们将不得不要求用户选择唯一性密钥。即使在这之后，如果我们有冲突，我们必须继续生成一个密钥，直到我们得到一个唯一的。

<figure><img src="../.gitbook/assets/image (16).png" alt=""><figcaption><p>URL缩短请求流程</p></figcaption></figure>

#### b、离线生成密钥

我们可以有一个独立的**密钥生成服务 (KGS)**，它预先生成随机的六字母字符串并将它们存储在数据库中（我们称之为 key-DB）。每当我们想要缩短 URL 时，我们只需使用一个已经生成的密钥并使用它。这种方法将使事情变得非常简单和快速。我们不仅不对 URL 进行编码，而且不必担心重复或冲突。KGS 将确保插入到 key-DB 中的所有密钥都是唯一的。

**并发会导致问题吗？** 一旦使用了密钥，就应该在数据库中对其进行标记，以确保它不会被重用。如果有多个服务器同时读取密钥，我们可能会遇到两个或更多服务器尝试从数据库中读取相同密钥的情况。我们如何解决这个并发问题？

服务器可以使用 KGS 读取/标记数据库中的密钥。KGS 可以使用两张表来存储密钥：一张用于存储尚未使用的密钥，一张用于存储所有已使用的密钥。一旦 KGS 将密钥提供给其中一台服务器，它就可以将它们移动到已使用的密钥表中。KGS 可以始终将一些密钥保存在内存中，以便在服务器需要它们时快速提供它们。

为简单起见，只要 KGS 在内存中加载一些键，它就可以将它们移动到已使用的键表中。这可确保每个服务器都获得唯一的密钥。如果 KGS 在将所有加载的密钥分配给某个服务器之前就挂了，我们将浪费这些密钥——考虑到我们拥有大量密钥，这是可以接受的。

KGS 还必须确保不要将相同的密钥提供给多个服务器。为此，它必须在从其中删除密钥并将它们提供给服务器之前同步（或锁定）持有密钥的数据结构。

**密钥数据库的大小是多少？**使用 base64 编码，我们可以生成 68.7B 的唯一六字母密钥。如果我们需要一个字节来存储一个字母数字字符，我们可以将所有这些键存储在：

```
6（每个键的字符）* 68.7B（唯一键）= 412 GB
```

**KGS不是单点故障吗？**是的。为了解决这个问题，我们可以有一个 KGS 的备用副本。每当主服务器死机时，备用服务器就可以接管以生成和提供密钥。

**每个应用服务器都可以缓存来自 key-DB 的一些键吗？**是的，这肯定可以加快速度。尽管在这种情况下，如果应用服务器在使用完所有密钥之前就挂了，我们最终会丢失这些密钥。这是可以接受的，因为我们有 68B 个唯一的六字母密钥。

**我们将如何执行密钥查找？** 我们可以在我们的数据库中查找密钥以获取完整的 URL。如果它存在于数据库中，则向浏览器发出“HTTP 302 重定向”状态，将存储的 URL 传递到请求的“位置”字段中。如果我们的系统中不存在该密钥，请发出“HTTP 404 Not Found”状态或将用户重定向回主页。

我们应该对自定义别名施加大小限制吗？我们的服务支持自定义别名。用户可以选择他们喜欢的任何“密钥”，但提供自定义别名不是强制性的。但是，对自定义别名施加大小限制是合理的（并且通常是可取的），以确保我们拥有一致的 URL 数据库。假设用户可以为每个客户键指定最多 16 个字符（如上面的数据库架构中所反映的）。

<figure><img src="../.gitbook/assets/image (15).png" alt=""><figcaption><p>URL缩短高级系统设计</p></figcaption></figure>

### 7、数据分区和复制

为了扩展我们的数据库，我们需要对其进行分区，以便它可以存储有关数十亿个 URL 的信息。我们需要提出一个分区方案，将我们的数据划分并存储到不同的数据库服务器中。

#### a、基于范围的分区

我们可以根据哈希键的第一个字母将 URL 存储在单独的分区中。因此，我们将所有以字母“A”（和“a”）开头的 URL 保存在一个分区中，将那些以字母“B”开头的 URL 保存在另一个分区中，依此类推。这种方法称为基于范围的分区。我们甚至可以将某些不太频繁出现的字母组合到一个数据库分区中。我们应该提出一个静态分区方案，以便我们始终可以以可预测的方式存储/查找 URL。

这种方法的主要问题是它可能导致数据库服务器不平衡。例如，我们决定将所有以字母“E”开头的 URL 放入 DB 分区，但后来我们意识到我们有太多以字母“E”开头的 URL。

#### b、基于散列的分区

在这个方案中，我们获取我们正在存储的对象的散列。然后我们根据哈希计算要使用的分区。在我们的例子中，我们可以使用“键”或短链接的哈希值来确定我们存储数据对象的分区。

我们的散列函数将随机分配 URL 到不同的分区（例如，我们的散列函数总是可以将任何“键”映射到 \[1…256] 之间的数字），这个数字将代表我们存储对象的分区。

这种方法仍然会导致分区过载，这可以通过使用[Consistent Hashing](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5709068098338816/)来解决。

### 8、缓存

我们可以缓存经常访问的 URL。我们可以使用一些现成的解决方案，比如[Memcached](https://en.wikipedia.org/wiki/Memcached)，它可以存储完整的 URL 及其各自的哈希值。应用服务器在访问后端存储之前，可以快速检查缓存是否具有所需的 URL。

**我们应该有多少缓存内存？**我们可以从每天 20% 的流量开始，根据客户的使用模式，我们可以调整我们需要多少缓存服务器。如上所述，我们需要 170GB 内存来缓存 20% 的日常流量。由于现代服务器可以拥有 256GB 内存，我们可以轻松地将所有缓存放入一台机器中。或者，我们可以使用几个较小的服务器来存储所有这些热门 URL。

**哪种缓存驱逐策略最适合我们的需求？**当缓存已满，并且我们想用更新/更热的 URL 替换链接时，我们将如何选择？最近最少使用 (LRU) 可能是我们系统的合理策略。根据此政策，我们会首先丢弃最近最少使用的 URL。我们可以使用[Linked Hash Map](https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html)或类似的数据结构来存储我们的 URL 和哈希，这也将跟踪最近访问过的 URL。

为了进一步提高效率，我们可以复制我们的缓存服务器以在它们之间分配负载。

**如何更新每个缓存副本？**每当缓存未命中时，我们的服务器就会访问后端数据库。每当发生这种情况时，我们都可以更新缓存并将新条目传递给所有缓存副本。每个副本都可以通过添加新条目来更新其缓存。如果副本已经有该条目，它可以简单地忽略它。

<figure><img src="../.gitbook/assets/image (9).png" alt=""><figcaption><p>访问缩短URL的请求流程</p></figcaption></figure>

### 9、负载均衡服务器（LB）

我们可以在系统的三个地方添加负载均衡层：

1. 客户端和应用服务器之间
2. 应用服务器和数据库服务器之间
3. 应用服务器和缓存服务器之间

最初，我们可以使用简单的循环方法，在后端服务器之间平均分配传入请求。这个 LB 实现简单，不会引入任何开销。这种方法的另一个好处是，如果服务器挂了，LB 将把它从轮换中取出，并停止向它发送任何流量。

Round Robin LB 的一个问题是我们没有考虑服务器负载。如果服务器过载或速度慢，LB 将不会停止向该服务器发送新请求。为了解决这个问题，可以放置一个更智能的 LB 解决方案，它会定期向后端服务器查询其负载并据此调整流量。

### 10.、清除或数据库清理

条目应该永远存在还是应该被清除？如果达到用户指定的过期时间，链接会发生什么？

如果我们选择主动搜索过期链接来删除它们，这会给我们的数据库带来很大的压力。相反，我们可以慢慢删除过期链接并进行惰性清理。我们的服务会确保只删除过期的链接，虽然有些过期的链接可以存活更长的时间但永远不会返回给用户。

* 每当用户尝试访问过期链接时，我们可以删除该链接并向用户返回错误。
* 可以定期运行单独的清理服务，以从我们的存储和缓存中删除过期链接。该服务应该是非常轻量级的，并且可以被调度为仅在预计用户流量较低时运行。
* 我们可以为每个链接设置一个默认的过期时间（例如，两年）。
* 删除过期链接后，我们可以将密钥放回密钥数据库中以供重复使用。
* 我们是否应该删除在一段时间内（比如六个月）未访问过的链接？这可能很棘手。由于存储变得越来越便宜，我们可以决定永远保持链接。

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption><p>URL缩短的详细组件设计</p></figcaption></figure>

### 11、 Telemetry

短 URL 被使用了多少次，用户的位置是什么，等等？我们将如何存储这些统计数据？如果它是在每个视图上更新的 DB 行的一部分，当一个流行的 URL 被大量并发请求猛击时会发生什么？

一些值得跟踪的统计数据：访问者所在的国家/地区、访问日期和时间、指向点击的网页、浏览器或访问页面的平台。

### 12、安全和权限

用户能否创建私有 URL 或允许一组特定用户访问 URL？

我们可以将权限级别（公共/私有）与数据库中的每个 URL 一起存储。我们还可以创建一个单独的表来存储有权查看特定 URL 的 UserID。如果用户没有权限并尝试访问 URL，我们可以发回错误 (HTTP 401)。鉴于我们将数据存储在像 Cassandra 这样的 NoSQL 宽列数据库中，表存储权限的键将是“哈希”（或 KGS 生成的“键”）。这些列将存储那些有权查看 URL 的用户的用户 ID。
