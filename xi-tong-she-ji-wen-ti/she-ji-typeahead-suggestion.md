# 设计 Typeahead Suggestion

## 设计 Typeahead Suggestion

让我们设计一个实时建议服务，在用户输入文字进行搜索时向他们推荐术语。

类似的服务：Auto-suggestions, Typeahead search

难度：中等



### 1、什么是Typeahead Suggestion？

Typeahead Suggestion使用户能够搜索已知和经常搜索的术语。当用户在搜索框中输入内容时，它会尝试根据用户输入的字符来预测查询，并给出完成查询的建议列表。预先输入的建议可帮助用户更好地表达他们的搜索查询。这不是要加快搜索过程，而是要指导用户并帮助他们构建搜索查询。



### 2、系统的要求和目标

#### 功能要求

当用户在他们的查询中输入时，我们的服务应该建议以用户输入的任何内容开头的前 10 个术语。

#### 非功能要求

建议应实时出现。用户应该能够在 200 毫秒内看到建议。



### 3、基本系统设计与算法

我们正在解决的问题是，我们需要以这样一种方式存储大量“字符串”，以便用户可以使用任何前缀进行搜索。我们的服务将建议与给定前缀匹配的下一个术语。例如，如果我们的数据库包含以下术语：cap、cat、captain 或 capital，并且用户输入了“cap”，我们的系统应该建议“cap”、“captain”和“capital”。

由于我们必须以最小的延迟处理大量查询，因此我们需要提出一种可以有效存储数据以便快速查询的方案。我们不能为此依赖某些数据库；我们需要以高效的数据结构将索引存储在内存中。

可以服务于我们目的的最合适的数据结构之一是 Trie。trie 是一种树状数据结构，用于存储短语，其中每个节点以顺序方式存储短语的字符。例如，如果我们需要在 trie 中存储“cap, cat, caption, Captain, Capital”，它看起来像：

\


<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

现在如果用户输入了'cap'，我们的服务可以遍历trie 去节点'P' 找到所有以这个前缀开头的词（例如，cap-tion、cap-ital 等）。

我们可以合并只有一个分支的节点以节省存储空间。上面的 trie 可以这样存储：

\
\


<figure><img src="../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

**我们应该有不区分大小写的 trie 吗？**为简单起见和搜索用例，我们假设我们的数据不区分大小写。

**如何找到最佳建议？** 现在我们可以找到给定前缀的所有术语，我们如何找到给定前缀的前 10 个术语？一个简单的解决方案是存储在每个节点处终止的搜索计数，例如，如果用户搜索了大约 100 次“CAPTAIN”和“CAPTION”500 次，我们可以将该数字与短语的最后一个字符一起存储。现在，如果用户键入“CAP”，我们知道前缀“CAP”下搜索次数最多的单词是“CAPTION”。因此，要找到给定前缀的最佳建议，我们可以遍历它下面的子树。

**给定一个前缀，遍历它的子树需要多少时间？**考虑到我们需要索引的数据量，我们应该期待一棵巨大的树。即使遍历子树也需要很长时间，例如，短语“系统设计面试问题”有 30 层深。由于我们有非常严格的延迟要求，我们确实需要提高解决方案的效率。

**我们可以存储每个节点的最佳建议吗？**这肯定可以加快我们的搜索速度，但需要大量额外的存储空间。我们可以在每个节点存储前 10 条建议，然后返回给用户。我们必须承受存储容量的大幅增加才能达到所需的效率。

我们可以通过只存储终端节点的引用而不是存储整个短语来优化我们的存储。要找到建议的术语，我们需要使用来自终端节点的父引用进行遍历。我们还需要存储每个参考的频率，以跟踪最重要的建议。

**我们将如何构建这个 trie？**我们可以有效地自下而上构建我们的 trie。每个父节点将递归调用所有子节点来计算他们的最佳建议和他们的计数。父节点将结合所有子节点的最佳建议来确定他们的最佳建议。

**如何更新trie？**假设每天有 50 亿次搜索，这将给我们每秒大约 6 万次查询。如果我们尝试为每个查询更新我们的 trie，它将非常耗费资源，这也会阻碍我们的读取请求。处理此问题的一种解决方案可能是在一定时间间隔后离线更新我们的 trie。

随着新查询的出现，我们可以记录它们并跟踪它们的频率。我们可以记录每个查询，或者每 1000 个查询进行采样和记录。例如，如果我们不想显示搜索次数少于 1000 次的词，则可以安全地记录每 1000 个搜索词。

我们可以有一个[Map-Reduce (MR)](https://en.wikipedia.org/wiki/MapReduce)设置来定期处理所有日志数据，比如每小时一次。这些 MR 作业将计算过去一小时内所有搜索词的频率。然后我们可以用这个新数据更新我们的 trie。我们可以获取 trie 的当前快照，并使用所有新术语及其频率对其进行更新。我们应该离线执行此操作，因为我们不希望我们的读取查询被更新特里请求阻塞。我们可以有两种选择：

1. 我们可以在每台服务器上制作一份 trie 副本以离线更新它。完成后，我们可以切换到开始使用它并丢弃旧的。
2. 另一种选择是我们可以为每个 trie 服务器配置一个主从配置。我们可以在主服务器服务流量时更新从服务器。更新完成后，我们就可以让 slave 成为我们的新 master。我们可以稍后更新我们的旧 master，然后它也可以开始服务流量。

**我们如何更新预先输入建议的频率？**由于我们正在存储每个节点的预输入建议的频率，因此我们也需要更新它们！我们只能更新频率差异，而不是从头开始重新计算所有搜索词。如果我们要统计过去 10 天内搜索的所有字词，我们需要从不再包含的时间段中减去计数，并添加新时间段的计数。我们可以根据每一项的[指数移动平均线 (EMA)](https://en.wikipedia.org/wiki/Moving\_average#Exponential\_moving\_average)来加减频率。在 EMA 中，我们更重视最新数据。它也被称为指数加权移动平均线。

在 trie 中插入一个新术语后，我们将转到短语的终端节点并增加其频率。由于我们将前 10 个查询存储在每个节点中，因此该特定搜索词可能会跳入其他几个节点的前 10 个查询。因此，我们需要更新这些节点的前 10 个查询。我们必须从节点一直遍历到根。对于每个父母，我们检查当前查询是否是前 10 名的一部分。如果是，我们更新相应的频率。如果不是，我们检查当前查询的频率是否高到足以进入前 10 名。如果是，我们插入这个新词并删除频率最低的词。

\
**我们如何从 trie 中删除一个术语？**假设由于某些法律问题或仇恨或盗版等原因，我们必须从 trie 中删除一个术语。当定期更新发生时，我们可以从 trie 中完全删除这些术语，同时，我们可以在每个服务器上添加一个过滤层，这将在将它们发送给用户之前删除任何此类术语。

**建议的不同排名标准可能是什么？** 除了简单的计数，对于术语排名，我们还必须考虑其他因素，例如新鲜度、用户位置、语言、人口统计、个人历史等。



### 4、Trie的永久存储 <a href="#div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px4-permanent-storage-of-the-tri" id="div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px4-permanent-storage-of-the-tri"></a>

**如何将 trie 存储在一个文件中，以便我们可以轻松地重建我们的 trie - 当机器重新启动时需要这样做？** 我们可以定期对我们的 trie 进行快照并将其存储在文件中。如果服务器出现故障，这将使我们能够重建 trie。要存储，我们可以从根节点开始，逐级保存trie。对于每个节点，我们可以存储它包含什么字符以及它有多少个子节点。在每个节点之后，我们应该放置它的所有子节点。假设我们有以下Tire：

\


<figure><img src="../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

\
如果我们将这个 trie 存储在具有上述方案的文件中，我们将有：“C2,A2,R1,T,P,O1,D”。由此，我们可以轻松地重建我们的 trie。

如果您注意到，我们不会在每个节点中存储最热门的建议及其计数。很难存储这些信息；由于我们的 trie 是自上而下存储的，我们没有在父节点之前创建子节点，因此没有简单的方法来存储它们的引用。为此，我们必须用计数重新计算所有最重要的项。这可以在我们构建 trie 时完成。每个节点将计算其最佳建议并将其传递给其父节点。每个父节点将合并其所有子节点的结果以找出其最佳建议。



### 5、规模估计 <a href="#div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px5-scale-estimationdiv" id="div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px5-scale-estimationdiv"></a>

如果我们正在构建一个与 Google 具有相同规模的服务，我们预计每天会进行 50 亿次搜索，这将给我们带来大约每秒 6 万次查询。

由于在 50 亿个查询中会有很多重复，我们可以假设其中只有 20% 是唯一的。如果我们只想索引前 50% 的搜索词，我们可以摆脱很多搜索频率较低的查询。假设我们将有 1 亿个要为其构建索引的唯一术语。

**存储估计：** 如果平均每个查询由 3 个单词组成，并且如果一个单词的平均长度是 5 个字符，这将为我们提供 15 个字符的平均查询大小。假设我们需要 2 个字节来存储一个字符，我们将需要 30 个字节来存储一个平均查询。所以我们需要的总存储空间：

```
1 亿 * 30 字节 => 3 GB
```

我们可以预计这些数据每天都会有所增长，但我们也应该删除一些不再搜索的术语。如果我们假设我们每天有 2% 的新查询，并且如果我们在过去一年维护我们的索引，我们应该期望的总存储量：

```
3GB + (0.02 * 3 GB * 365 天) => 25 GB
```

### 6、数据分区

尽管我们的索引可以轻松地放在一台服务器上，但我们仍然可以对其进行分区以满足我们对更高效率和更低延迟的要求。我们如何有效地对数据进行分区以将其分发到多个服务器上？

#### a、基于范围的分区

我们根据首字母将短语存储在单独的分区中会怎样。因此，我们将所有以字母“A”开头的术语保存在一个分区中，将那些以字母“B”开头的术语保存到另一个分区中，依此类推。我们甚至可以将某些不太频繁出现的字母组合到一个分区中。我们应该静态地提出这种分区方案，以便我们始终可以以可预测的方式存储和搜索术语。

这种方法的主要问题是它可能导致服务器不平衡，例如，如果我们决定将所有以字母“E”开头的术语放在一个分区中，但后来我们意识到我们有太多以字母开头的术语'E' 表示我们无法放入一个分区。

#### b、根据服务器的最大容量进行分区

假设我们根据服务器的最大内存容量对 trie 进行分区。只要服务器有可用内存，我们就可以继续在服务器上存储数据。每当子树无法放入服务器时，我们就会在该处打破分区以将该范围分配给该服务器，然后移至下一个服务器以重复此过程。假设我们的第一个 trie 服务器可以存储从“A”到“AABC”的所有术语，这意味着我们的下一个服务器将从“AABD”开始存储。如果我们的第二个服务器最多可以存储“BXA”，那么下一个服务器将从“BXB”开始，依此类推。我们可以保留一个哈希表来快速访问这个分区方案：

服务器 1、A-AABC&#x20;

服务器 2、AABD-BXA&#x20;

服务器 3、BXB-CDA

对于查询，如果用户输入了“A”，我们必须同时查询服务器 1 和 2 以找到最热门的建议。当用户输入“AA”时，我们仍然需要查询服务器 1 和 2，但是当用户输入“AAA”时，我们只需要查询服务器 1。

我们可以在我们的 trie 服务器前面有一个负载均衡器，它可以存储此映射并重定向流量。此外，如果我们从多个服务器查询，我们需要在服务器端合并结果以计算总体最佳结果，或者让我们的客户端这样做。如果我们更喜欢在服务器端这样做，我们需要在负载均衡器和 trie 服务器之间引入另一层服务器（我们称它们为聚合器）。这些服务器将聚合来自多个 trie 服务器的结果并将排名靠前的结果返回给客户端。

基于最大容量的分区仍然可以将我们带到热点，例如，如果有很多以“cap”开头的术语的查询，那么与其他服务器相比，持有它的服务器将具有较高的负载。

#### c、基于**术语哈希的分**

每个术语将被传递给一个哈希函数，该函数将生成一个服务器编号，我们将把术语存储在该服务器上。这将使我们的术语分布随机，从而最大限度地减少热点。这种方案的缺点是，要找到一个术语的预先输入建议，我们必须询问所有服务器，然后汇总结果。



### **7、**缓存

我们应该意识到缓存热门搜索词对我们的服务非常有帮助。将有一小部分查询负责大部分流量。我们可以在保存最常搜索词及其预先输入建议的 trie 服务器前面有单独的缓存服务器。应用程序服务器应该在访问 trie 服务器之前检查这些缓存服务器，以查看它们是否具有所需的搜索词。这将节省我们遍历 tri 的时间。

我们还可以构建一个简单的机器学习 (ML) 模型，该模型可以尝试根据简单的计数、个性化或趋势数据来预测每个建议的参与度，并预先缓存这些术语。



### 8、复制和负载均衡器 <a href="#div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px8-replication-and-load-balance" id="div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px8-replication-and-load-balance"></a>

我们应该为我们的 trie 服务器创建副本，以实现负载平衡和容错。我们还需要一个负载均衡器来跟踪我们的数据分区方案并根据前缀重定向流量。



### 9、容错

**当 trie 服务器宕机时会发生什么？**如上所述，我们可以进行主从配置；如果 master 死了，slave 可以在故障转移后接管。任何恢复的服务器都可以根据最后一个快照重建 trie。



### 10、Typeahead 客户端

我们可以在客户端进行以下优化以提升用户体验：

1. 如果用户在 50 毫秒内没有按下任何键，客户端应该只尝试访问服务器。
2. 如果用户不断打字，客户端可以取消正在进行的请求。
3. 最初，客户端可以等到用户输入几个字符。
4. 客户端可以从服务器预先获取一些数据以保存未来的请求。
5. 客户可以在本地存储最近的建议历史记录。最近的历史具有非常高的重用率。
6. 与服务器建立早期连接是最重要的因素之一。一旦用户打开搜索引擎网站，客户端就可以打开与服务器的连接。因此，当用户输入第一个字符时，客户端不会浪费时间建立连接。
7. 服务器可以将部分缓存推送到 CDN 和 Internet 服务提供商 (ISP) 以提高效率。



### 11、个性化

用户会根据他们的历史搜索、位置、语言等收到一些预先输入的建议。我们可以将每个用户的个人历史单独存储在服务器上，也可以将它们缓存在客户端上。服务器可以在将这些个性化术语发送给用户之前将其添加到最终集合中。个性化搜索应始终排在其他搜索之前。
