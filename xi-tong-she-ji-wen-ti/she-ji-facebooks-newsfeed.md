# 设计Facebook’s Newsfeed

## 设计Facebook’s Newsfeed

让我们设计 Facebook’s Newsfeed，它将包含来自用户关注的所有人员和页面的帖子、照片、视频和状态更新。

类似服务：Twitter Newsfeed、Instagram Newsfeed、Quora Newsfeed

难度级别：难

### 1、Facebook’s Newsfeed是什么？

NewsFeed是Facebook 主页中间不断更新的故事列表。它包括状态更新、照片、视频、链接、应用程序活动以及来自用户在 Facebook 上关注的人员、页面和群组的“点赞”。换句话说，它是您朋友和您的生活故事的完整可滚动版本的汇编，来自照片、视频、位置、状态更新和其他活动。

对于你设计的任何社交媒体网站——Twitter、Instagram 或 Facebook——你都需要一些新闻源系统来显示来自朋友和追随者的更新。



### 2、系统的要求和目标

让我们为 Facebook 设计一个Newsfeed，满足以下要求：

**功能要求：**

1. Newsfeed将根据用户关注的人员、页面和组中的帖子生成。
2. 用户可能有很多朋友并关注大量页面/组。
3. 提要可能包含图像、视频或仅包含文本。
4. 我们的服务应该支持在新帖子到达所有活跃用户的Newsfeed时附加它们。

**非功能性要求：**

1. 我们的系统应该能够实时生成任何用户的新闻源——最终用户看到的最大延迟为 2 秒。
2. 假设有新的新闻提要请求进入，则帖子不应超过 5 秒才能进入用户的提要。



### 3、容量估计和约束

假设用户平均有 300 个朋友并关注 200 个页面。

**流量估算：**假设每天有 3 亿活跃用户，每个用户平均每天获取 5 次时间线。这将导致每天 1.5B 的新闻提要请求或每秒大约 17,500 个请求。

**存储估计：**平均而言，假设我们需要在每个用户的提要中拥有大约 500 个帖子，我们希望将这些帖子保存在内存中以便快速获取。我们还假设平均每个帖子的大小为 1KB。这意味着我们需要为每个用户存储大约 500KB 的数据。要为所有活跃用户存储所有这些数据，我们需要 150TB 的内存。如果一个服务器可以容纳 100GB，我们需要大约 1500 台机器来为所有活跃用户保留前 500 个帖子。

### 4、系统API

> 💡      一旦我们最终确定了需求，定义系统 API 总是一个好主意。这应该明确说明对系统的期望。

我们可以使用 SOAP 或 REST API 来公开我们服务的功能。以下可能是用于获取新闻源的 API 的定义：

```
getUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies)
```

**参数：**\
api\_dev\_key（string）：注册的 API 开发人员密钥可用于根据分配的配额限制用户。\
**user\_id（number）：**系统将为其生成新闻源的用户的 ID。\
**since\_id（number）：**可选；返回 ID 高于（即比指定 ID 更新）的结果。\
**计数（number）：**可选；指定要尝试检索的提要项目数，每个不同请求最多检索 200 个。\
**max\_id（number）：**可选；返回 ID 小于（即早于）或等于指定 ID 的结果。\
**exclude\_replies(boolean)：**可选；此参数将防止回复出现在返回的时间线中。

**返回：**  (JSON) 返回一个包含提要项目列表的 JSON 对象。

### 5、数据库设计

存在三个主要对象：用户、实体（例如页面、组等）和 FeedItem（或 Post）。以下是对这些实体之间关系的一些观察：

* 用户可以关注其他实体并与其他用户成为朋友。
* 用户和实体都可以发布包含文本、图像或视频的 FeedItem。
* 每个 FeedItem 都有一个 UserID，它指向创建它的用户。为简单起见，我们假设只有用户可以创建提要项目，尽管在 Facebook 页面上也可以发布提要项目。
* 每个 FeedItem 都可以有一个 EntityID 指向创建该帖子的页面或组。

如果我们使用关系数据库，我们需要对两种关系建模：用户-实体关系和 FeedItem-媒体关系。由于每个用户可以与很多人成为朋友并关注很多实体，因此我们可以将此关系存储在单独的表中。“UserFollow”中的“Type”列标识被关注的实体是用户还是实体。同样，我们可以有一个 FeedMedia 关系表。

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

### 6、高层次系统设计

在高层次上，这个问题可以分为两个部分：

**提要生成：**新闻提要是从用户关注的用户和实体（页面和组）的帖子（或提要项）生成的。因此，每当我们的系统收到为用户（比如 Jane）生成提要的请求时，我们将执行以下步骤：

1. 检索 Jane 关注的所有用户和实体的 ID。
2. 检索这些 ID 的最新、最受欢迎和相关的帖子。这些是我们可以在简的新闻源中显示的潜在帖子。
3. 根据与简的相关性对这些帖子进行排名。这代表简的当前提要。
4. 将此提要存储在缓存中并返回要在简的提要上呈现的热门帖子（例如 20 个）。
5. 在前端，当 Jane 到达她当前提要的末尾时，她可以从服务器获取接下来的 20 个帖子，依此类推。

这里要注意的一件事是，我们生成了一次提要并将其存储在缓存中。Jane 关注的人的新帖子怎么样？如果Jane 在线，我们应该有一种机制来对这些新帖子进行排名并将其添加到她的提要中。我们可以定期（比如每五分钟）执行上述步骤来对新帖子进行排名并将其添加到她的提要中。然后可以通知简，她的提要中有更新的项目可以获取

**提要发布：**每当 Jane 加载她的新闻提要页面时，她都必须从服务器请求和拉取提要项目。当她到达当前提要的末尾时，她可以从服务器中提取更多数据。对于较新的项目，服务器可以通知 Jane，然后她可以拉取或推送这些新帖子。稍后我们将详细讨论这些选项。

概括地说，我们的 Newsfeed 服务需要以下组件：

1. **Web 服务器：**保持与用户的连接。此连接将用于在用户和服务器之间传输数据。
2. **应用服务器：**执行在数据库服务器中存储新帖子的工作流程。我们还需要一些应用服务器来检索新闻源并将其推送给最终用户。
3. **元数据数据库和缓存：**存储有关用户、页面和组的元数据。
4. **帖子数据库和缓存：**存储有关帖子及其内容的元数据。
5. **视频和照片存储以及缓存：** Blob 存储，用于存储帖子中包含的所有媒体。
6. **新闻源生成服务：**为用户收集和排名所有相关帖子以生成新闻源并存储在缓存中。该服务还将接收实时更新并将这些较新的提要项添加到任何用户的时间线。
7. **提要通知服务：**通知用户有更新的项目可用于他们的新闻提要。

以下是我们系统的高级架构图。用户 B 和 C 正在关注用户 A。

<figure><img src="../.gitbook/assets/image (7).png" alt=""><figcaption><p>Facebook 新闻提要架构</p></figcaption></figure>

### 7、详细的组件设计

让我们详细讨论我们系统的不同组件。

#### a、**提要生成**

让我们以新闻提要生成服务为例，它从 Jane 关注的所有用户和实体中获取最新帖子；查询将如下所示：

```
(SELECT FeedItemID FROM FeedItem WHERE UserID in (
    SELECT EntityOrFriendID FROM UserFollow WHERE UserID = <current_user_id> and type = 0(user))
)
UNION
(SELECT FeedItemID FROM FeedItem WHERE EntityID in (
    SELECT EntityOrFriendID FROM UserFollow WHERE UserID = <current_user_id> and type = 1(entity))
)
ORDER BY CreationDate DESC 
LIMIT 100
```

以下是提要生成服务设计的问题：

1. 对于有很多朋友/关注的用户来说，速度非常慢，因为我们必须对大量帖子进行排序/合并/排名。
2. 当用户加载他们的页面时，我们会生成时间线。这将非常缓慢并且具有很高的延迟。
3. 对于实时更新，每次状态更新都会导致所有关注者的提要更新。这可能会导致我们的新闻源生成服务中的大量积压。
4. 对于实时更新，服务器向用户推送（或通知）较新的帖子可能会导致非常重的负载，尤其是对于拥有大量关注者的人或页面而言。为了提高效率，我们可以预先生成时间线并将其存储在内存中。

**新闻源的离线生成：** 我们可以有专门的服务器不断生成用户的新闻源并将它们存储在内存中。因此，每当用户为其提要请求新帖子时，我们都可以简单地从预先生成的存储位​​置提供它。使用这种方案，用户的新闻源不是在加载时编译，而是定期编译，并在用户请求时返回给用户。

每当这些服务器需要为用户生成提要时，它们将首先查询以查看上次为该用户生成提要的时间。然后，从那时起将生成新的提要数据。我们可以将这些数据存储在哈希表中，其中“key”是 UserID，“value”是这样的 STRUCT：

```
Struct {
    LinkedHashMap<FeedItemID, FeedItem> feedItems;
    DateTime lastGenerated;
}
```

我们可以将 FeedItemID 存储在类似于[Linked HashMap](https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html)或[TreeMap](https://docs.oracle.com/javase/6/docs/api/java/util/TreeMap.html)的数据结构中，这样我们不仅可以跳转到任何提要项，还可以轻松地遍历Map。每当用户想要获取更多的提要项目时，他们可以发送他们当前在他们的新闻提要中看到的最后一个 FeedItemID，然后我们可以在我们的哈希映射中跳转到该 FeedItemID 并从那里返回下一批/页面的提要项目。

**我们应该在内存中为用户的提要存储多少提要项？**最初，我们可以决定为每个用户存储 500 个提要项，但这个数字可以在以后根据使用模式进行调整。例如，如果我们假设用户提要的一页有 20 个帖子，并且大多数用户从不浏览他们提要的十页以上，我们可以决定每个用户只存储 200 个帖子。对于任何想要查看更多帖子（超过内存中存储的帖子）的用户，我们始终可以查询后端服务器。

**我们应该为所有用户生成（并保存在内存中）新闻源吗？**会有很多用户不经常登录。以下是我们可以做的一些事情来解决这个问题；1) 更直接的方法是，使用基于 LRU 的缓存，可以从内存中删除长时间未访问其新闻源的用户 2) 更智能的解决方案可以找出用户的登录模式以预先生成他们的新闻源，例如，用户在一天中的什么时间处于活动状态以及用户在一周中的哪几天访问他们的新闻源？等等

现在让我们讨论下一节中“实时更新”问题的一些解决方案。

#### b、**Feed 发布**

将帖子推送给所有关注者的过程称为扇出。以此类推，push 方法称为 fanout-on-write，而 pull 方法称为 fanout-on-load。让我们讨论向用户发布提要数据的不同选项。

1. **“Pull” model or Fan-out-on-load:** 此方法涉及将所有最近的提要数据保存在内存中，以便用户可以在需要时从服务器中拉取它。客户可以定期或在需要时手动提取提要数据。这种方法可能存在的问题是 a) 在用户发出拉取请求之前，新数据可能不会显示给用户，b) 很难找到正确的拉取节奏，因为大多数情况下，拉取请求会导致空响应是没有新数据，造成资源浪费。
2. **“Push” model or Fan-out-on-write:** 对于推送系统，一旦用户发布了帖子，我们可以立即将帖子推送给所有关注者。优点是在获取提要时，您无需浏览朋友列表并获取每个人的提要。它显着减少了读取操作。为了有效地处理这个问题，用户必须与服务器保持一个 [Long Poll](https://en.wikipedia.org/wiki/Push\_technology#Long\_polling) 请求以接收更新。这种方法的一个可能问题是，当用户拥有数百万粉丝（名人用户）时，服务器必须将更新推送给很多人。
3. **Hybrid:** 处理馈送数据的另一种方法可以是使用混合方法，即进行写入时扇出和加载时扇出的组合。具体来说，我们可以停止推送来自拥有大量粉丝（名人用户）的用户的帖子，而只推送那些拥有数百（或数千）粉丝的用户的数据。对于名人用户，我们可以让粉丝拉更新。由于推送操作对于有很多朋友或关注者的用户来说代价非常高，通过禁用他们的扇出，我们可以节省大量的资源。另一种替代方法可能是，一旦用户发布帖子，我们可以将扇出限制为仅她的在线朋友。此外，为了从这两种方法中获益，“推送通知”和“拉取服务”最终用户的组合是一个很好的方法。

**在每个请求中，我们可以向客户端返回多少个 Feed 项？**我们应该对用户在一个请求中可以获取的项目数设置一个最大限制（比如 20 个）。但是，我们应该让客户端指定每个请求需要多少个提要项，因为用户可能希望根据设备（移动设备与桌面设备）获取不同数量的帖子。

**如果有新帖子可用于他们的新闻源，我们是否应该始终通知用户？**每当有新数据可用时，用户收到通知可能很有用。然而，在数据使用相对昂贵的移动设备上，它可能会消耗不必要的带宽。因此，至少对于移动设备，我们可以选择不推送数据，而是让用户“拉动刷新”来获取新帖子。

### 8、Feed排名

在新闻源中对帖子进行排名最直接的方法是根据帖子的创建时间，但今天的排名算法所做的远不止于此，以确保“重要”帖子的排名更高。排名的高级思想是首先选择使帖子重要的关键“信号”，然后找出如何将它们结合起来计算最终的排名分数。

更具体地说，我们可以选择与任何提要项的重要性相关的特征，例如点赞数、评论数、分享数、更新时间、帖子是否有图像/视频等，然后，分数可以使用这些特征进行计算。对于一个简单的排名系统来说，这通常就足够了。更好的排名系统可以通过不断评估我们在用户粘性、留存率、广告收入等方面是否取得进展来显着提高自身。



### 9、数据分区

#### a、**分片帖子和元数据**

由于我们每天都有大量的新帖子，而且我们的读取负载也非常高，我们需要将我们的数据分布到多台机器上，以便我们可以高效地读取/写入它。为了对存储帖子及其元数据的数据库进行分片，我们可以采用类似[设计 Twitter](she-ji-twitter.md)中讨论的设计。

#### b、Feed数据

对于存储在内存中的 feed 数据，我们可以根据 UserID 对其进行分区。我们可以尝试将用户的所有数据存储在一台服务器上。存储时，我们可以将 UserID 传递给我们的哈希函数，该函数会将用户映射到缓存服务器，我们将在其中存储用户的提要对象。此外，对于任何给定的用户，由于我们不希望存储超过 500 个 FeedItmeID，因此我们不会遇到用户的提要数据不适合单个服务器的情况。要获取用户的提要，我们总是只需要查询一台服务器。为了未来的增长和复制，我们必须使用[Consistent Hashing](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5709068098338816)。
