# 设计 Youtube 或 Netflix

## 设计 Youtube 或 Netflix

让我们设计一个像 Youtube 这样的视频共享服务，用户可以在其中上传/查看/搜索视频。

类似服务：netflix.com、vimeo.com、dailymotion.com、veoh.com&#x20;

难度级别：中等



### 1、为什么选择Youtube？

Youtube 是世界上最受欢迎的视频分享网站之一。该服务的用户可以上传、查看、分享、评价和报告视频以及添加对视频的评论。

### 2、系统的要求和目标



为了这个练习，我们计划设计一个更简单的 Youtube 版本，具有以下要求：

#### 功能要求：

1. 用户应该能够上传视频。
2. 用户应该能够分享和观看视频。
3. 用户应该能够根据视频标题执行搜索。
4. 我们的服务应该能够记录视频的统计数据，例如喜欢/不喜欢、总观看次数等。
5. 用户应该能够添加和查看视频评论。

**非功能性要求：**

1. 该系统应该是高可靠的，任何上传的视频都不会丢失。
2. 系统应该是高可用的。一致性可能会受到影响（为了可用性）；如果用户有一段时间没有看到视频，可以接受。
3. 用户在观看视频时应该有实时体验，并且不应该感到任何延迟。

**不在范围内：**视频推荐、最受欢迎的视频、频道、订阅、稍后观看、收藏等。



### 3、容量估计和约束

假设我们有 15 亿总用户，其中 8 亿是每日活跃用户。如果平均而言，用户每天观看五个视频，那么每秒的总视频观看次数将是：

```
800M * 5 / 86400 秒 => 46K 视频/秒
```

假设我们的上传：观看比率为 1:200，即，对于每个视频上传，我们查看了 200 个视频，即每秒上传 230 个视频。

```
46K / 200 => 230 个视频/秒
```

**存储估算：**假设每分钟有 500 小时的视频上传到 Youtube。如果平均而言，一分钟的视频需要 50MB 的存储空间（视频需要以多种格式存储），则一分钟内上传的视频所需的总存储空间为：

```
500 小时 * 60 分钟 * 50MB => 1500 GB/分钟（25 GB/秒）
```

这些数字是在忽略视频压缩和复制的情况下估计的，这会改变我们的估计。

**带宽估计：**每分钟上传 500 小时的视频，假设每个视频上传需要 10MB/分钟的带宽，我们每分钟将获得 300GB 的上传量。

```
500 小时 * 60 分钟 * 10MB => 300GB/分钟（5GB/秒）
```

假设上传：观看比率为 1:200，我们将需要 1TB/s 的传出带宽。



### 4、系统API <a href="#div-stylecolorblack-background-colore2f4c7-border-radius5pxpadding5px4-system-apisdiv" id="div-stylecolorblack-background-colore2f4c7-border-radius5pxpadding5px4-system-apisdiv"></a>

我们可以使用 SOAP 或 REST API 来公开我们服务的功能。以下可能是用于上传和搜索视频的 API 的定义：

{% code overflow="wrap" %}
```
uploadVideo(api_dev_key, video_title, vide_description, tags[], category_id, default_language, recording_details, video_contents)
```
{% endcode %}

**参数：**\
api\_dev\_key(string)：注册账号的API开发者密钥。除其他外，这将用于根据分配的配额限制用户。\
video\_title（string）：视频的标题。\
vide\_description（string）：视频的可选描述。\
tags (string\[])：视频的可选标签。\
category\_id（string）：视频的类别，例如电影、歌曲、人物等。\
default\_language（string）：例如英语、普通话、印地语等\
recording\_details（string）：录制视频的位置。\
video\_contents（stream）：要上传的视频。

**返回：（**字符串）\
成功上传将返回 HTTP 202（已接受请求），一旦视频编码完成，用户将通过电子邮件收到通知，其中包含访问视频的链接。我们还可以公开一个可查询的 API，让用户知道他们上传视频的当前状态。

{% code overflow="wrap" %}
```
searchVideo(api_dev_key, search_query, user_location, maximum_videos_to_return, page_token)
```
{% endcode %}

**参数：**\
api\_dev\_key(string)：我们服务注册账号的API开发者密钥。\
search\_query(string)：包含搜索词的字符串。\
user\_location（string）：执行搜索的用户的可选位置。\
maximum\_videos\_to\_return (number)：一个请求中返回的最大结果数。\
page\_token（字符串）：此令牌将指定结果集中应返回的页面。

**返回：** (JSON)\
一个 JSON，其中包含有关与搜索查询匹配的视频资源列表的信息。每个视频资源都有一个视频标题、一个缩略图、一个视频创建日期和一个观看次数。

```
streamVideo(api_dev_key, video_id, offset, codec, resolution)
```

**参数：**\
api\_dev\_key(string)：我们服务注册账号的API开发者密钥。\
video\_id（string）：用于标识视频的字符串。\
offset（number）：我们应该能够从任何偏移量流式传输视频；这个偏移量是从视频开始的秒数。如果我们支持从多个设备播放/暂停视频，我们需要将偏移量存储在服务器上。这将使用户能够从他们离开的同一点开始在任何设备上观看视频。\
codec（string）和resolution（string）：我们应该从客户端发送 API 中的编解码器和分辨率信息，以支持多个设备的播放/暂停。想象一下，您正在电视的 Netflix 应用程序上观看视频，将其暂停，然后开始在手机的 Netflix 应用程序上观看。在这种情况下，您将需要编解码器和分辨率，因为这两种设备具有不同的分辨率并使用不同的编解码器。

**返回：** (STREAM)\
来自给定偏移量的媒体流（视频块）。



### 5、高层次设计

在高层次上，我们需要以下组件：

1. **处理队列：**每个上传的视频将被推送到处理队列，以便稍后出列进行编码、缩略图生成和存储。
2. **编码器：**将每个上传的视频编码为多种格式。
3. **缩略图生成器：**为每个视频生成一些缩略图。
4. **视频和缩略图存储：**将视频和缩略图文件存储在一些分布式文件存储中。
5. **用户数据库：**用于存储用户的信息，例如姓名、电子邮件、地址等。
6. **视频元数据存储：**一个元数据数据库，用于存储有关视频的所有信息，如标题、系统中的文件路径、上传用户、总观看次数、喜欢、不喜欢等。它还将用于存储所有视频评论。

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Youtube的高层次设计</p></figcaption></figure>

### 6、数据库模式



**视频元数据存储 - MySql**\
视频元数据可以存储在 SQL 数据库中。每个视频都应存储以下信息：

* 视频ID
* 标题
* 描述
* 尺寸
* 缩略图
* 上传者/用户
* 总赞数
* 不喜欢的总数
* 总观看次数

对于每条视频评论，我们需要存储以下信息：

* 评论ID
* 视频ID
* 用户身份
* 评论
* 创作时间

**用户数据存储——MySql**

* 用户 ID、姓名、电子邮件、地址、年龄、注册详细信息等。



### 7、详细的组件设计

该服务的读取量很大，因此我们将专注于构建一个可以快速检索视频的系统。我们可以预期我们的读写比率为 200:1，这意味着每个视频上传有 200 个视频观看。

**视频将存储在哪里？**视频可以存储在[HDFS](https://en.wikipedia.org/wiki/Apache\_Hadoop#HDFS)或[GlusterFS](https://en.wikipedia.org/wiki/GlusterFS)等分布式文件存储系统中。

**我们应该如何有效地管理读流量？**我们应该将我们的读取流量与写入流量分开。由于我们将有每个视频的多个副本，我们可以将我们的读取流量分布在不同的服务器上。对于元数据，我们可以有主从配置，写的内容会先到主服务器，然后在所有的从服务器上应用。这样的配置可能会造成数据的滞后，例如，当一个新的视频被添加时，它的元数据将首先被插入主服务器，在它被应用到从服务器之前，我们的从服务器将无法看到它；因此，它将向用户返回滞后的结果。在我们的系统中，这种滞后可能是可以接受的，因为它将是非常短暂的，用户将能够在几毫秒后看到新的视频。

**缩略图将存储在哪里？**缩略图将比视频多得多。如果我们假设每个视频都有五个缩略图，那么我们需要一个非常高效的存储系统来服务于巨大的读取流量。在决定应该为缩略图使用哪个存储系统之前，有两个考虑因素：

1. 缩略图是小文件，例如，每个最大 5KB。
2. 与视频相比，缩略图的阅读流量将是巨大的。用户将一次观看一个视频，但他们可能正在查看一个包含 20 个其他视频缩略图的页面。

让我们评估将所有缩略图存储在磁盘上。鉴于我们有大量文件，我们必须对磁盘上的不同位置执行大量搜索才能读取这些文件。这是非常低效的，并且会导致更高的延迟。

[Bigtable](https://en.wikipedia.org/wiki/Bigtable)在这里可以是一个合理的选择，因为它将多个文件组合成一个块存储在磁盘上，并且在读取少量数据时非常有效。这两者都是我们服务的两个最重要的要求。将热缩略图保留在缓存中也将有助于改善延迟，并且鉴于缩略图文件的大小很小，我们可以轻松地将大量此类文件缓存在内存中。

**视频上传：** 由于视频可能很大，如果在上传连接断开时，我们应该支持从同一点恢复。

**视频编码：**将新上传的视频存储在服务器上，并在处理队列中添加一个新任务，将视频编码为多种格式。完成所有编码后，将通知上传者并且视频可供查看/共享。

<figure><img src="../.gitbook/assets/image (6).png" alt=""><figcaption><p>Youtube的详细组件设计<br></p></figcaption></figure>

### 8、元数据分片

由于我们每天都有大量的新视频，并且我们的读取负载非常高，因此，我们需要将我们的数据分布到多台机器上，以便我们可以高效地执行读/写操作。我们有很多选择来分片我们的数据。让我们逐一介绍对这些数据进行分片的不同策略：

**基于 UserID 的分片：** 我们可以尝试将特定用户的所有数据存储在一台服务器上。在存储时，我们可以将 UserID 传递给我们的哈希函数，该函数会将用户映射到数据库服务器，我们将在其中存储该用户视频的所有元数据。在查询用户的视频时，我们可以要求我们的哈希函数找到保存用户数据的服务器，然后从那里读取它。要按标题搜索视频，我们必须查询所有服务器，每个服务器将返回一组视频。然后，集中式服务器将汇总这些结果并对其进行排名，然后再将它们返回给用户。

这种方法有几个问题：

1. 如果用户变得流行怎么办？持有该用户的服务器上可能有很多查询；这可能会造成性能瓶颈。这也会影响我们服务的整体表现。
2. 随着时间的推移，与其他用户相比，一些用户最终可能会存储大量视频。保持不断增长的用户数据的均匀分布非常棘手。

为了从这些情况中恢复，我们必须重新分区/重新分配我们的数据，或者使用一致的散列来平衡服务器之间的负载。

**基于 VideoID 的分片：**我们的哈希函数会将每个 VideoID 映射到一个随机服务器，我们将在其中存储该视频的元数据。要查找用户的视频，我们将查询所有服务器，每个服务器将返回一组视频。集中式服务器将在将这些结果返回给用户之前对其进行汇总和排名。这种方法解决了我们的热门用户问题，但将其转移到了热门视频。

我们可以通过在数据库服务器前引入缓存来存储热门视频来进一步提高性能。



### 9、视频去重 <a href="#div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px9-video-deduplicationdiv" id="div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px9-video-deduplicationdiv"></a>

随着大量用户上传大量视频数据，我们的服务将不得不处理广泛的视频复制。重复的视频通常在宽高比或编码方面有所不同，可能包含叠加层或额外的边框，或者可能是较长的原始视频的摘录。重复视频的泛滥可能会在多个层面产生影响：

1. 数据存储：我们可能会通过保留同一视频的多个副本来浪费存储空间。
2. 缓存：重复的视频会占用可用于独特内容的空间，从而导致缓存效率下降。
3. 网络使用：重复的视频也会增加必须通过网络发送到网络内缓存系统的数据量。
4. 资源消耗：更高的存储、低效的缓存和网络使用可能导致资源浪费。

对于最终用户而言，这些低效率将以重复搜索结果、更长的视频启动时间和流式传输中断的形式体现。

对于我们的服务，重复数据删除在早期是最有意义的；当用户上传视频而不是对其进行后处理以稍后查找重复视频时。内联重复数据删除将为我们节省大量可用于编码、传输和存储视频副本的资源。一旦任何用户开始上传视频，我们的服务就可以运行视频匹配算法（例如， [块匹配](https://en.wikipedia.org/wiki/Block-matching\_algorithm)、[相位相关](https://en.wikipedia.org/wiki/Phase\_correlation)等）来查找重复项。如果我们已经有正在上传的视频的副本，我们可以停止上传并使用现有副本，或者继续上传并使用新上传的视频（如果质量更高）。如果新上传的视频是现有视频的子部分，或者反之亦然，我们可以智能地将视频分成更小的块，以便我们只上传丢失的部分。



### 10、负载均衡

我们应该在缓存服务器之间使用[一致性哈希](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5709068098338816/)，这也有助于平衡缓存服务器之间的负载。由于我们将使用基于静态哈希的方案将视频映射到主机名，因此由于每个视频的受欢迎程度不同，可能会导致逻辑副本上的负载不均匀。例如，如果一个视频变得流行，则与该视频对应的逻辑副本将比其他服务器经历更多的流量。然后，逻辑副本的这些不均匀负载可以转化为相应物理服务器上的不均匀负载分布。要解决此问题，一个位置的任何繁忙服务器都可以将客户端重定向到同一缓存位置中不太繁忙的服务器。对于这种情况，我们可以使用动态 HTTP 重定向。

然而，使用重定向也有它的缺点。首先，由于我们的服务尝试在本地进行负载平衡，如果接收重定向的主机无法提供视频，则会导致多次重定向。此外，每次重定向都需要客户端发出额外的 HTTP 请求；在视频开始播放之前，它还会导致更高的延迟。此外，层间（或跨数据中心）重定向会将客户端引导到较远的缓存位置，因为较高层的缓存仅存在于少数位置。



### 11、缓存 <a href="#div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px11-cachediv" id="div-stylecolorblack-background-colore2f4c7-border-radius5px-padding5px11-cachediv"></a>

为了服务全球分布的用户，我们的服务需要一个大规模的视频传输系统。我们的服务应该使用大量地理分布的视频缓存服务器将其内容推向更靠近用户的地方。我们需要制定一种策略，以最大限度地提高用户性能，并在其缓存服务器上平均分配负载。

我们可以为元数据服务器引入缓存来缓存热数据库行。在访问数据库之前使用 Memcache 缓存数据和应用程序服务器可以快速检查缓存是否有所需的行。最近最少使用（LRU）可能是我们系统的合理缓存驱逐策略。根据此政策，我们首先丢弃最近最少查看的行。

**我们如何构建更智能的缓存？**如果我们遵循 80-20 规则，即 20% 的视频每日阅读量产生 80% 的流量，这意味着某些视频非常受欢迎，以至于大多数人观看它们；因此，我们可以尝试缓存 20% 的每日视频和元数据读取量。



### 12、内容分发网络(CDN)

CDN 是一个分布式服务器系统，它根据用户的地理位置、网页的来源和内容交付服务器向用户交付 Web 内容。看看我们[缓存](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5643440998055936)章节中的“CDN”部分。

我们的服务可以将热门视频移至 CDN：

* CDN在多个地方复制内容。视频有更好的机会离用户更近，而且，由于跳跃次数更少，视频将从一个更友好的网络上流传。
* CDN机器大量使用缓存，并且大多可以从内存中提供视频。

不被 CDN 缓存的不太受欢迎的视频（每天 1-20 次观看）可以由我们在各个数据中心的服务器提供。



### 13、容错

我们应该使用[一致性哈希](https://www.educative.io/collection/page/5668639101419520/5649050225344512/5709068098338816/)在数据库服务器之间进行分配。一致的散列不仅有助于替换挂掉的服务器，还有助于在服务器之间分配负载。
