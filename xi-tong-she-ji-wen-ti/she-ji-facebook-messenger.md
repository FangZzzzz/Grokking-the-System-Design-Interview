# 设计 Facebook Messenger

## 设计 Facebook Messenger

\
让我们设计一个像Facebook Messenger这样的即时消息服务，用户可以用过Web和移动界面相互发送文本信息。



### 1、什么是 Facebook Messenger

Facebook Messenger是一款向用户提供基于文本的即时消息服务的软件应用程序。Messenger用户可以通过手机和Facebook的网站与他们的Facebook朋友聊天。



### 2、系统的要求和目标

我们的Messenger应满足以下要求：

#### 功能要求

1. Messenger 应该支持用户之间的一对一对话。
2. Messenger 应跟踪其用户的在线/离线状态。
3. Messenger 应支持聊天记录的持久存储。

#### 非功能性要求

1. 用户应该以最小的延迟获得实时聊天体验。
2. 我们的系统应该是高度一致的；用户应该能够在所有设备上看到相同的聊天记录。
3. Messenger 的高可用性是可选的；为了一致性，我们可以容忍较低的可用性。

#### 扩展要求

* 群聊：Messenger应该支持多人在一个群组中相互交谈。
* 推送通知：Messenger应该能够在用户离线时通知用户新消息。



### 3、容量估计和约束

假设我们每天有5亿活跃用户，平均每隔用户每天发送40条消息；这每天给我们带来200亿条消息。

**存储估计：**假设一条消息平均为100bytes，因此要存储一天所有的消息，我们需要2TB的存储空间。

```
200 亿条消息 * 100 bytes => 2 TB/天
```

要存储五年的聊天记录，我们需要3.6PB的存储空间。

```
2 TB * 365 天 * 5 年 ~= 3.6 PB
```

除了聊天消息，我们还需要存储用户信息、消息元数据（ID、时间戳等）。更何况上面的计算没有考虑数据压缩和复制。

**带宽估计**：如果我们的服务每天获取2TB的数据，这讲为我们提供每秒25MB的传入数据。

```
2 TB / 86400 秒 ~= 25 MB/秒
```

由于每条传入消息都需要发送给另一个用户，因此上传和下载都需要25MB/s的相同带宽。

**高层次估计：**

| 消息总数 | 200亿/天 |
| ---- | ------ |
| 每天存储 | 2TB    |
| 存储5年 | 3.6PB  |
| 传入数据 | 25MB/秒 |
| 传出数据 | 25MB/秒 |

### **4、高层次设计**

在高层次上，我们需要一个聊天服务器作为中心部分，协调用户之间的所有通信。当一个用户想向另一个用户发送消息时，他们将连接到聊天服务器并将消息发送到服务器；然后服务器将该消息传递给其他用户并将其存储在数据库中。

<figure><img src="../.gitbook/assets/image (19).png" alt=""><figcaption><p>高层次设计</p></figcaption></figure>

详细的工作流程如下所示：

1. 用户 A 通过聊天服务器向用户 B 发送消息。
2. 服务器接收到消息并向用户 A 发送确认。
3. 服务器将消息存储在其数据库中并将消息发送给用户 B。
4. 用户 B 接收到消息并将确认发送到服务器。
5. 服务器通知User-A消息已成功传递给User-B。

<figure><img src="../.gitbook/assets/image (1) (2).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (14) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (2) (1).png" alt=""><figcaption><p>发送消息的请求流程</p></figcaption></figure>

### 5、详细的组件设计

让我们首先尝试构建一个简单的解决方案，其中所有内容都在一台服务器上运行。在高层次上，我们的系统需要处理以下用例：

1. 接收传入消息并传递传出消息。
2. 从数据库中存储和检索消息。
3. 记录哪些用户在线或离线，并通知所有相关用户这些状态变化。

让我们一一谈谈这些场景：

#### a、消息处理

**我们如果有效发送/接收消息？**要发送消息，用户需要连接到服务器并向其他用户发布消息。要从服务器获取消息，用户有两种选择：

1. **Pull模型：**用户可以定期询问服务器是否有新消息给他们。
2. **Push模型：**用户可以保持与服务器的连接打开，并且可以依赖服务器在有新消息时通知他们。

如果我们采用第一种方法，那么服务器需要跟踪仍在等待传递的消息，并且一旦接受用户连接到服务器以请求任何新消息，服务器就可以返回所有待处理的消息。为了最大限度地减少用户的延迟，他们必须非常频繁地检查服务器，并且大多数时候如果没有待处理的消息，他们将得到一个空响应。这会浪费大量资源，而且看起来不是一个有效的解决方案。

如果我们采用第二种方法，所有活动用户都保持与服务器的连接打开，那么一旦服务器收到消息，它就可以立即将消息传递给目标用户。这样，服务器不需要跟踪待处理的消息，并且我们将有最小的延迟，因为消息会在打开的连接上立即传递。

**客户端如果保持与服务器的开放连接？**我们可以使用HTTP长轮询（Long Pull）或WebSockets，在长轮询中，客户端可以向服务器请求信息，但期望服务器可能不会立即响应。如果在收到轮询时服务器没有新的数据给客户端，服务器不会发送空响应，而是保持请求打开并等待响应信息可用。一旦它确实有新信息，服务器立即将响应发送给客户端，完成开放的请求。在收到服务器的响应后，客户端可以立即发出另一个服务器请求，以获得未来的更新。这在延迟、吞吐量和性能方面提供了很多改进。长轮询请求可能会超时或接受到与服务器的断开连接，在这种情况下，客户端必须要打开一个新请求。

**服务器如何跟踪所有打开的连接以有效地将消息重定向到用户？**服务器可以维护一个Hash表，其中“Key”是用户ID，“Value”是连接对象。因此，每当服务器收到用户的消息时，它都会在Hash表中查找该用户以找到连接对象并在打开请求时发送消息。

**当服务器收到一个用户下线的消息时会发生什么？**如果接收方已断开连接，服务器可以通知发送方发送失败。如果是临时断开连接，例如，接收方的长轮询请求刚刚超时，那么我们应该期待用户重新连接。在这种情况下，我们可以要求发件人重试发送消息。这种重试可以嵌入到客户端的逻辑中，这样用户就不必重新键入消息。服务器还可以将消息存储一段时间，并在接收方重新连接后重试发送。

**我们需要多少聊天服务器？**让我们随时计划 5 亿连接。假设现代服务器可以随时处理 50K 并发连接，我们将需要 10K 这样的服务器。

**我们如何知道哪个服务器持有与哪个用户的连接？**我们可以在我们的聊天服务器前引入一个软件负载均衡器；可以将每个 UserID 映射到服务器以重定向请求。

**服务器应该如何处理“传递消息”请求？**

服务器收到新消息后需要做以下事情：

1. 将消息存储在数据库中。
2. 将消息发送给接收者。
3. 发送确认给发送者。

聊天服务器将首先找到为接收者保持连接的服务器，并将消息传递给该服务器以将其发送给接收者。然后聊天服务器可以将确认发送给发送者；我们不需要等待将消息存储在数据库中（这可以在后台发生）。存储消息将在下一节中讨论。

**messenger如何维护消息的顺序？**我们可以为每条消息存储一个时间戳，即服务器接受到消息的时间。这仍然不能确保客户端消息的正确排序。服务器时间戳无法确定消息的确切顺序的情况如下所示：

1. 用户1向用户2的服务器发送消息M1。
2. 服务器在T1收到M1。
3. 同时，用户2向用户1发送消息M2到服务器。
4. 服务器在T2接收到消息M2，使得T2>T1。
5. 服务器将消息M1发送给用户2，将M2发送给用户1。

所以用户1会先看到M1然后是M2，而用户2会先看到M2然后是M1。

为了解决这个问题，我们需要为每隔客户端的每条消息保留一个序列号。此序列号将确定每个用户的消息的确切顺序。使用此解决方案，两个客户端将看到消息序列的不同视图，但此视图在所有设备上对它们来说都是一致的。

#### b、从数据库存储和检索消息

每当聊天服务器收到一条新消息时，它都需要将其存储在数据库中。为此，我们有两种选择：

1. 启动一个单独的线程，它将与数据库一起存储消息。
2. 向数据库发送异步请求以存储消息。

在设计数据库时，我们必须牢记以下几点：

1. 如何有效地使用数据库连接池。
2. 如何重试失败的请求。
3. 在哪里记录那些重试后仍然失败的请求。
4. 当所有问题都解决后，如何重试这些记录的请求（重试后失败）。

**我们应该使用哪种存储系统？**我们需要一个能够支持非常高的小更新率并且能够快速获取一系列记录的数据库。这是必需的，因为我们有大量的小消息需要插入到数据库中，并且在查询时，用户最感兴趣的是顺序访问这些消息。

我们不能像 MySQL 那样使用 RDBMS，也不能像 MongoDB 这样使用 NoSQL，因为每次用户接收/发送消息时，我们都无法从数据库中读取/写入一行。这不仅会使我们服务的基本操作以高延迟运行，而且会给数据库造成巨大的负载。

[使用HBase](https://en.wikipedia.org/wiki/Apache\_HBase)等宽列数据库解决方案可以轻松满足我们的两个要求。HBase 是一个面向列的键值 NoSQL 数据库，它可以将多个值针对一个键存储到多个列中。HBase 以 Google 的[BigTable](https://en.wikipedia.org/wiki/Bigtable)为模型，运行在 Hadoop 分布式文件系统 ( [HDFS](https://en.wikipedia.org/wiki/Apache\_Hadoop) ) 之上。HBase 将数据组合在一起以将新数据存储在内存缓冲区中，一旦缓冲区已满，它将数据转储到磁盘。这种存储方式不仅有助于快速存储大量小数据，而且还可以通过键或扫描行的范围来获取行。HBase 也是一个高效的数据库来存储可变大小的数据，这也是我们的服务所需要的。

**客户端应该如何有效地从服务器获取数据？**客户端在从服务器获取数据时应该分页。对于不同的客户端，页面大小可能不同，例如，手机屏幕较小，因此我们需要在视口中进行较少数量的消息/对话。

#### c、管理用户状态

我们需要跟踪用户的在线/离线状态，并在状态发生变化时通知所有相关用户。由于我们在服务器上为所有活动用户维护了一个连接对象，因此我们可以很容易地从中找出用户的当前状态。任何时候都有 500M 的活跃用户，如果我们必须将每个状态变化广播给所有相关的活跃用户，将会消耗大量资源。我们可以围绕这个做以下优化：

1. 每当客户端启动应用程序时，它可以拉取好友列表中所有用户的当前状态。
2. 每当用户向另一个已离线的用户发送消息时，我们都可以向发送者发送失败消息并更新客户端上的状态。
3. 每当用户上线时，服务器总是可以延迟几秒钟的时间广播该状态，以查看用户是否没有立即下线。
4. 客户端可以从服务器中提取有关用户视口上显示的用户的状态。这不应该是一个频繁的操作，因为服务器正在广播用户的在线状态，我们可以忍受用户过时的离线状态一段时间。
5. 每当客户端与另一个用户开始新的聊天时，我们都可以拉取当时的状态。

\


<figure><img src="../.gitbook/assets/image (15) (2).png" alt=""><figcaption><p>Facebook messenger的详细组件设计</p></figcaption></figure>

**设计总结：** 客户端会打开与聊天服务器的连接来发送消息；然后服务器会将其传递给请求的用户。所有活动用户都将与服务器保持连接以接收消息。每当有新消息到达时，聊天服务器都会在长轮询请求中将其推送给接收用户。消息可以存储在 HBase 中，它支持快速小更新和基于范围的搜索。服务器可以将用户的在线状态广播给其他相关用户。客户端可以以较低频率为在客户端视口中可见的用户提取状态更新。\


### 6、数据分区

由于我们将存储大量数据（5 年 3.6PB），我们需要将其分布到多个数据库服务器上。我们的分区方案是什么？

**基于 UserID 的分区：**假设我们基于 UserID 的哈希进行分区，以便我们可以将用户的所有消息保存在同一个数据库中。如果一个 DB 分片是 4TB，我们将拥有“3.6PB/4TB \~= 900”分片五年。为简单起见，假设我们保留 1K 分片。所以我们将通过“hash(UserID) % 1000”找到分片号，然后从那里存储/检索数据。这种分区方案也可以非常快速地为任何用户获取聊天记录。

一开始，我们可以从较少的数据库服务器开始，多个分片驻留在一台物理服务器上。由于我们可以在一台服务器上拥有多个数据库实例，因此我们可以轻松地在一台服务器上存储多个分区。我们的哈希函数需要理解这种逻辑分区方案，以便它可以在一台物理服务器上映射多个逻辑分区。

由于我们将存储无限的历史消息，我们可以从大量的逻辑分区开始，这些逻辑分区将映射到更少的物理服务器，随着存储需求的增加，我们可以添加更多的物理服务器来分配我们的逻辑分区。

**基于 MessageID 的分区：**如果我们将用户的不同消息存储在不同的数据库分片上，获取聊天的一系列消息会很慢，所以我们不应该采用这种方案。



### 7、缓存

我们可以在用户视口中可见的一些最近的对话中缓存一些最近的消息（比如最后 15 条消息）（比如最后 5 条消息）。由于我们决定将所有用户的消息存储在一个分片上，因此用户的缓存也应该完全驻留在一台机器上。



### 8、负载均衡

我们的聊天服务器前需要一个负载均衡器；它可以将每个 UserID 映射到为用户保存连接的服务器，然后将请求定向到该服务器。同样，我们的缓存服务器也需要一个负载均衡器。

### 9、容错和复制

**当聊天服务器出现故障时会发生什么？**我们的聊天服务器与用户保持联系。如果服务器出现故障，我们是否应该设计一种机制将这些连接转移到其他服务器？将 TCP 连接故障转移到其他服务器非常困难；一种更简单的方法是让客户端在连接丢失时自动重新连接。

**我们应该存储用户消息的多个副本吗？**我们不能只拥有用户数据的一份副本，因为如果保存数据的服务器崩溃或永久关闭，我们没有任何机制来恢复该数据。为此，要么我们必须将数据的多个副本存储在不同的服务器上，要么使用像 Reed-Solomon 编码这样的技术来分发和复制它。



### 10、扩展要求

#### a、群聊

我们可以在我们的系统中拥有单独的群聊对象，这些对象可以存储在聊天服务器上。群聊对象由 GroupChatID 标识，并且还将维护属于该聊天的人员的列表。我们的负载均衡器可以根据 GroupChatID 引导每个群聊消息，并且处理该群聊的服务器可以遍历聊天的所有用户，以找到处理每个用户的连接以传递消息的服务器。

在数据库中，我们可以将所有群聊存储在基于 GroupChatID 分区的单独表中。

#### b、推送通知

在我们当前的设计中，用户只能向活动用户发送消息，如果接收用户离线，我们会向发送用户发送失败消息。推送通知将使我们的系统能够向离线用户发送消息。

对于推送通知，每个用户都可以从他们的设备（或网络浏览器）选择加入，以便在有新消息或事件时获取通知。每个制造商都维护一组服务器来处理将这些通知推送给用户。

为了在我们的系统中有推送通知，我们需要设置一个通知服务器，它将为离线用户获取消息并将它们发送到制造商的推送通知服务器，然后将它们发送到用户的设备。
