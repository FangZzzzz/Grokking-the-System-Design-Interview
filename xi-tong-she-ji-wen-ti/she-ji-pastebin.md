# 设计 Pastebin

## 设计Pastebin

让我们设计一个类似Pastebin的Web服务，用户可以在其中访问纯文本。该服务的用户将输入一段文本并获得一个随机生成的URL来访问它。

类似服务：pastebin.com、pastebin.co、chopapp.com

难度级别：简单

### 1、什么是Pastebin

类似 Pastebin 的服务使用户能够通过网络（通常是 Internet）存储纯文本或图像，并生成唯一的 URL 来访问上传的数据。此类服务还用于通过网络快速共享数据，因为用户只需传递 URL 即可让其他用户看到。

如果您以前没有使用过[pastebin.com](http://pastebin.com/)，请尝试在那里创建一个新的“粘贴”，并花一些时间了解他们的服务提供的不同选项。这对你理解本章有很大帮助。

### 2、系统的要求和目标

我们的 Pastebin 服务应满足以下要求：

#### 功能要求：

1. 用户应该能够上传或“粘贴”他们的数据并获得一个唯一的 URL 来访问它。
2. 用户将只能上传文本。
3. 数据和链接将在特定时间跨度后自动过期；用户还应该能够指定到期时间。
4. 用户应该可以选择为其粘贴选择自定义别名。

#### 非功能性要求：

1. 该系统应该是高可靠的，任何上传的数据都不应丢失。
2. 系统应该是高可用的。这是必需的，因为如果我们的服务关闭，用户将无法访问他们的粘贴。
3. 用户应该能够以最小的延迟实时访问他们的粘贴。
4. 粘贴链接不应被猜测（不可预测）。

#### 扩展要求：

1. 分析，例如，一个粘贴被访问了多少次？
2. 其他服务也应该可以通过 REST API 访问我们的服务。

### 3、一些设计考虑

Pastebin 与[设计像TinyURL这样的URL缩短服务](she-ji-xiang-tinyurl-zhe-yang-de-url-suo-duan-fu-wu.md)有一些相同的要求，但我们应该牢记一些额外的设计注意事项。

**用户一次可以粘贴的文本量应该是多少？**我们可以限制用户不要拥有大于 10MB 的粘贴，以阻止滥用服务。

**我们应该对自定义 URL 施加大小限制吗？**由于我们的服务支持自定义 URL，用户可以选择他们喜欢的任何 URL，但提供自定义 URL 不是强制性的。但是，对自定义 URL 施加大小限制是合理的（并且通常是可取的），以便我们拥有一致的 URL 数据库。

### 4、 容量估计和约束

我们的服务阅读量很大；与创建新的粘贴相比，将会有更多的读取请求。我们可以假设读写之间的比率为 5:1。

**流量估计：** Pastebin 服务预计不会有类似于 Twitter 或 Facebook 的流量，让我们在这里假设我们每天有 100 万个新的粘贴添加到我们的系统中。这使我们每天有 500 万次阅读。

每秒新粘贴数：

```
1M /（24 小时 * 3600 秒）~= 12 次粘贴/秒
```

每秒粘贴读取次数：

```
5M /（24 小时 * 3600 秒）~= 58 次读取/秒
```

**存储估计：** 用户最多可以上传10MB的数据；通常使用类似 Pastebin 的服务来共享源代码、配置或日志。这样的文本并不大，所以我们假设每个粘贴平均包含 10KB。

按照这个速度，我们每天将存储 10GB 的数据。

```
1M * 10KB => 10 GB/天
```

如果我们想将这些数据存储十年，我们将需要 36TB 的总存储容量。

每天使用 100 万个粘贴，我们将在 10 年内拥有 36 亿个粘贴。我们需要生成和存储密钥来唯一标识这些粘贴。如果我们使用 base64 编码（\[AZ, az, 0-9, ., -]），我们需要六个字母的字符串：

```
64^6 ~= 687 亿个唯一字符串
```

如果存储一个字符需要一个字节，存储 3.6B 个键所需的总大小将是：

```
3.6B * 6 => 22 GB
```

与 36TB 相比，22GB 可以忽略不计。为了保持一定的空余量，我们将假设一个 70% 容量的模型（这意味着我们不想在任何时候使用超过 70% 的总存储容量），这将我们的存储需求提高到 51.4TB。

**带宽估计：** 对于写入请求，我们预计每秒有 12 个新粘贴，导致每秒 120KB 的入口。

```
3.6B * 6 => 22 GB
```

至于读取请求，我们预计每秒有 58 个请求。因此，总数据输出（发送给用户）将为 0.6 MB/s。

```
58 * 10KB => 0.6 MB/s
```

虽然总入口和出口并不大，但我们在设计服务时应该牢记这些数字。

**内存估计：** 我们可以缓存一些经常访问的热粘贴。遵循 80-20 规则，即 20% 的热贴产生 80% 的流量，我们希望缓存这 20% 的粘贴。

由于我们每天有 5M 的读取请求，要缓存 20% 的请求，我们需要：

```
0.2 * 5M * 10KB ~= 10 GB
```

### 5、系统API

我们可以使用 SOAP 或 REST API 来公开我们服务的功能。以下可能是用于创建/检索/删除粘贴的 API 的定义：

{% code overflow="wrap" %}
```
addPaste(api_dev_key, paste_data, custom_url=None user_name=None, paste_name=None, expire_date=None)
```
{% endcode %}

参数：&#x20;

api\_dev\_key(string)：注册账号的API开发者密钥。除其他外，这将用于根据分配的配额限制用户。&#x20;

paste\_data(string)：粘贴的文本数据。&#x20;

custom\_url(string)：可选的自定义 URL。&#x20;

user\_name(string)：用于生成 URL 的可选用户名。&#x20;

paste\_name(string)：粘贴的可选名称&#x20;

expire\_date(string)：粘贴的可选到期日期。

**返回：**(string) 插入成功返回可以访问粘贴的 URL，否则将返回错误代码。

同样，我们可以检索和删除粘贴 API：

```
getPaste(api_dev_key, api_paste_key)
```

其中“apiPasteKey”是一个字符串，表示要检索的粘贴的粘贴键。此 API 将返回粘贴的文本数据。

```
deletePaste(api_dev_key, api_paste_key)
```

成功删除返回“True”，否则返回“False”。

### 6、数据库设计

关于我们存储的数据性质的一些观察：

1. 我们需要存储数十亿条记录。
2. 我们存储的每个元数据对象都很小（小于 1KB）。
3. 我们存储的每个粘贴对象都可以是中等大小（可以是几 MB）。
4. 记录之间没有关系，除非我们想存储哪个用户创建了什么粘贴。
5. 我们的服务阅读量很大。

我们需要两张表，一张用于存储有关粘贴的信息，另一张用于存储用户数据。

<figure><img src="../.gitbook/assets/image (7) (1).png" alt=""><figcaption><p>数据库设计</p></figcaption></figure>

这里，'URlHash' 是 TinyURL 的 URL 等价物，'ContentKey' 是对存储粘贴内容的外部对象的引用；我们将在本章后面讨论粘贴内容的外部存储。

### 7、高层次设计（High level design ，HLD）

在高层次上，我们需要一个应用层来服务所有的读写请求。应用层将与存储层对话以存储和检索数据。我们可以将我们的存储层与一个数据库隔离，该数据库存储与每个粘贴、用户等相关的元数据，而另一个将粘贴内容存储在一些对象存储中（如[Amazon S3](https://en.wikipedia.org/wiki/Amazon\_S3)）。这种数据划分也将允许我们单独扩展它们。

<figure><img src="../.gitbook/assets/image (8) (1).png" alt=""><figcaption><p>高层次设计（High level design ，HLD）</p></figcaption></figure>

### 8、组件设计

#### a、应用层

我们的应用层将处理所有传入和传出的请求。应用程序服务器将与后端数据存储组件对话以服务请求。

**如何处理写请求？**收到写入请求后，我们的应用服务器会生成一个六字母的随机字符串，作为粘贴的密钥（如果用户没有提供自定义密钥）。然后应用服务器将粘贴的内容和生成的密钥存储在数据库中。插入成功后，服务器可以将密钥返回给用户。这里一个可能的问题可能是由于重复键而导致插入失败。由于我们正在生成一个随机密钥，因此新生成的密钥有可能与现有密钥匹配。在这种情况下，我们应该重新生成一个新密钥并重试。我们应该继续重试，直到我们没有看到由于重复密钥而导致的失败。如果他们提供的自定义键已经存在于我们的数据库中，我们应该向用户返回一个错误。

上述问题的另一种解决方案可能是运行独立的**密钥生成服务**(KGS) 预先生成随机的六个字母字符串并将它们存储在数据库中（我们称之为 key-DB）。每当我们想要存储一个新的粘贴时，我们将只取一个已经生成的密钥并使用它。这种方法将使事情变得非常简单和快速，因为我们不会担心重复或冲突。KGS 将确保插入到 key-DB 中的所有密钥都是唯一的。KGS 可以使用两张表来存储密钥，一张用于存储尚未使用的密钥，一张用于存储所有已使用的密钥。一旦 KGS 向应用程序服务器提供了一些密钥，它就可以将这些密钥移动到已使用的密钥表中。KGS 可以始终将一些密钥保存在内存中，以便在服务器需要它们时，它可以快速提供它们。一旦 KGS 在内存中加载了一些密钥，它就可以将它们移动到已使用的密钥表中，这样我们就可以确保每个服务器都获得唯一的密钥。如果 KGS 在使用内存中加载的所有密钥之前就挂了，我们将浪费这些密钥。我们可以忽略这些键，因为我们有大量的键。

**KGS不会单点故障吗？**是的。为了解决这个问题，我们可以拥有一个 KGS 的备用副本，并且只要主服务器死机，它就可以接管以生成和提供密钥。

**每个应用服务器都可以缓存来自 key-DB 的一些键吗？**是的，这肯定可以加快速度。尽管在这种情况下，如果应用服务器在使用完所有密钥之前就挂了，我们最终会丢失这些密钥。这是可以接受的，因为我们有 68B 个唯一的六个字母键，这比我们需要的要多得多。

**它如何处理粘贴读取请求？**收到读取粘贴请求后，应用程序服务层会查询数据存储。数据存储区搜索密钥，如果找到，则返回粘贴的内容。否则，返回错误代码。

#### b、数据存储层

我们可以将数据存储层分为两层：

1. 元数据数据库：我们可以使用 MySQL 等关系数据库或 Dynamo 或 Cassandra 等分布式键值存储。
2. 对象存储：我们可以将我们的内容存储在像 Amazon 的 S3 这样的对象存储中。每当我们想要达到内容存储的全部容量时，我们可以通过添加更多服务器轻松增加容量。

<figure><img src="../.gitbook/assets/image (6) (1).png" alt=""><figcaption><p>组件设计</p></figcaption></figure>

### 9、 清除或数据库清理

请参阅[设计像TinyURL这样的URL缩短服务](she-ji-xiang-tinyurl-zhe-yang-de-url-suo-duan-fu-wu.md)。

### 10、数据分区和复制

请参阅[设计像TinyURL这样的URL缩短服务](she-ji-xiang-tinyurl-zhe-yang-de-url-suo-duan-fu-wu.md)。

### 11、缓存和负载均衡器

请参阅[设计像TinyURL这样的URL缩短服务](she-ji-xiang-tinyurl-zhe-yang-de-url-suo-duan-fu-wu.md)。

### 12、 安全和权限

请参阅[设计像TinyURL这样的URL缩短服务](she-ji-xiang-tinyurl-zhe-yang-de-url-suo-duan-fu-wu.md)。
